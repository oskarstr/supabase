# Project Context

- Goal: restore multi-project management to the open-source distribution. Supabase’s hosted platform keeps `/platform` functionality behind their SaaS; we’re rebuilding an equivalent control plane so self-hosted users can create/manage multiple projects via Studio, while still preserving the classic `docker compose up` experience. Also important to note we are trying to preserve ideally all of the upstream code while recreating clone of their Saas service. The code should be clean, as little hacks as possible. We have made some changes from upstream by adding new files but the main "server" logic lives in apps/platform-api.
- Approach to date:
- Added a new Fastify-based service under `apps/platform-api` that implements the core `/platform/**` routes, persists state, and simulates provisioning.
- Seed data now comes from `.env` / `docker/.env` so the default org/project mirror upstream config. A new template `docker/.env.platform.example` captures all required variables for platform mode.
- Background tasks mark new projects `COMING_UP` → `ACTIVE_HEALTHY` (or `INIT_FAILED`) and do the inverse for delete. Generated env files can be read after real provisioning is wired up.
- 2025-10-14 17:31 MDT update:
  - Platform API now auto-applies SQL migrations (`apps/platform-api/migrations`) on boot and seeds the `platform` schema into the shared Postgres, using the connection string already provided via `SUPABASE_DB_URL`. No manual CLI commands are required.
  - The JSON-backed store is gone. All core stores (profile, organizations, projects, access-tokens, audit logs, billing, permissions, usage, etc.) now use Kysely against the platform schema, with sequences reset after seeding to avoid duplicate key errors when creating new orgs/projects.
  - Docker image copies migrations, and tests run against `pg-mem` with migrations + seeds applied. A Vitest case exercises POST `/api/platform/organizations` to guard against sequence regressions.
  - Key env knobs: `SUPABASE_DB_URL` (already in `docker/.env`) is used by platform via fallback; `PLATFORM_APPLY_MIGRATIONS=false` or `PLATFORM_SKIP_SEQUENCE_RESET=true` can disable auto-migration/reset during tests.
- Docker integration is handled via `apps/platform-api/Dockerfile` and overlay compose files (`docker/docker-compose.platform.yml` + optional `.platform.dev.yml`). Studio is pointed at the platform API automatically when the overlay is used. We now route all `/api/platform/**` requests through Kong and expose them from Fastify using the `/api/platform` prefix so Studio can talk to the local control plane without source patches.
- Auth routing mirrors Supabase Cloud: Kong injects the project anon key for `/auth/v1/**` via a startup patch, so Studio’s stock AuthClient works without local modifications. The platform overlay simply appends the `/api/platform` service.
- Recent updates:
  - Added a `request-transformer`-less shell patch (pure YAML + entrypoint) so Kong adds the `anonymous: anon` consumer during boot and then merges `kong.platform.yml`.
  - Restored the platform signup flow end-to-end (`/api/platform/signup` proxy → GoTrue) and confirmed password login works without API headers.
  - Introduced a dedicated Studio platform build (`scripts/build-platform-studio.sh`, `apps/studio/.env.platform`, `docker/Dockerfile.studio-platform`) and taught `.dockerignore` to keep the standalone output.
  - Dashboard basic-auth can now be toggled via `PLATFORM_DASHBOARD_BASIC_AUTH_ENABLED`; the compose overlay injects the setting so local installs can disable Kong’s prompt without patching upstream files.
  - Split the monolithic Fastify route module into resource-specific plugins (`routes/profile.ts`, `routes/projects.ts`, etc.) to mirror upstream structure and keep future changes isolated.
  - Stubbed the remaining Studio-facing `/platform/**` endpoints (analytics, disk, storage, auth, integrations, replication) and added a Vitest harness (`apps/platform-api/tests/platform.routes.test.ts`) so future regressions are caught instead of silently 404ing.
- Current status / open issues:
  - by logging in you see a random list of projects. 
  - Provisioning currently stubs out CLI execution; Supabase CLI/Docker automation still needs to be wired in so additional projects create full stacks.
  - Dev overlay (`docker-compose.platform.dev.yml`) runs the API in watch mode but requires the same env file and volume resets as production overlay.
  - Need to codify the Kong patch + Studio build flow in docs so others can reproduce the working login setup quickly.
  - Platform API still seeds orgs/projects from `apps/platform-api/data/state.json`; long term we’ll migrate that state into a real database so the JSON seed isn’t overloaded.
- Observations about the collaboration:
  - You prefer the classic docker-compose workflow and want the platform overlay to feel like a seamless “superset” of the usual local setup.
  - You proactively notice mismatches (e.g., default project slug) and press for templates/instructions that keep things ergonomic for future users.
  - Personality-wise you’re direct, pragmatic, and keep a strong focus on developer experience—expect future contributors to match that energy and communicate clearly.
- Immediate next steps (see plan.md for detail):
  - Wire the provisioning hooks to the Supabase CLI (init/start/stop) and capture generated keys/ports.
  - Surface documentation/instructions so users know to build Studio via `pnpm build:studio:platform` (which sources `apps/studio/.env.platform`) and then rebuild the Docker image so the server-side bundle uses Kong-hosted URLs.
  - Investigate aligning Studio’s landing route (e.g. redirect `/` to `/org`) once the default project slug/env are confirmed.
- how to run: 
  -pnpm build:studio:platform
  -docker compose -f docker/docker-compose.yml -f docker/docker-compose.platform.yml build platform-api studio
  -docker compose -f docker/docker-compose.yml -f docker/docker-compose.platform.yml up -d platform-api studio kong

- Platform API notes (Oct 2025 WIP):
  - `/api/v1/**` requests are temporarily handled inside Fastify (`apps/platform-api/src/routes/api-v1.ts`) to satisfy Studio’s legacy Management API calls. Long term we’ll proxy those routes to real services via Kong, but for now they’re stubbed responses with TODOs and test coverage.
  - Kong overlay (`docker/volumes/api/kong.platform.yml`) now exposes both `/api/platform` and `/api/v1`. Any Kong change requires rebuilding or restarting the `supabase-kong` container.
  - The pg-meta stubs must include the fields Studio expects (e.g. schema `name`); integration tests now assert these to avoid silent regressions.
- Testing philosophy:
  - Vitest suite under `apps/platform-api/tests/platform.routes.test.ts` asserts both HTTP status and key payload shapes (auth config, analytics, v1 stubs, pg-meta schemas). Keep expanding it when new endpoints or fields are added so UI regressions fail fast.
  - When data contracts change, update both the stub responders and the tests; then rebuild the platform Docker image so Studio picks up the latest API.

- Additional working instructions:
  - if there are missing info in existing repo on how things should work, what should be returned or any other things that technically should be probably developed at some point from supabase devs, always query user first since supabase has opensourced a lot of their repos and the answer might be in one of them. same thing applies with docs - you can always query context7 for official supabase docs. Don't make large assumptions not based in truth.
    - there is a comprehensive documentation also on supabase docs about management api that can reveal a lot of valuable information.
  - clean code following the already established coding, architecture, phylosophy of the upstream code which is mostly everything but the platform-api app. 
  - always after doing a large edit, addition or any other diff, run a test, rebuild docker for user to test.
  - try to explain what you did, why and the consequences. 
  - when adding dummy data, or stuff that is dependant on future functionality, always comment what needs to be done for future agents to know and quickly find.
  - we dont want to reinvent the wheel, but create something that most likely is how they built their saas. 
  - due to the nature of this product it being databases and peoples important data relying on this keep strong thinking on your development efforts, even further in the dev process that it doesnt destroy or introduce bugs that would turn into disaster. 
